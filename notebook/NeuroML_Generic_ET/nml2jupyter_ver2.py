import pylab as plt
import numpy as np
import os
import re
import ipywidgets
import xml.etree.ElementTree as ET

#python helper class for updating NeuroML files and running it from Jupyter Notebook
class nml2jupyter():
    
    def __init__(self, path2source, fname_LEMS):
        
        self.path2source      = path2source
        self.fname_LEMS       = fname_LEMS
        self.filelist         = []
        
    #function to get list of  filenames from LEMS and all subsequent files
    def getFileList(self,filename,filelist_local):
        
        filelist_local.append(filename)              #add current file to filelist
        pathfilename=os.path.join(self.path2source, filename)
        root = ET.parse(pathfilename).getroot()
        
        #parse current file for tag names 'include' and append included files in filelist
        for child in root:
            tag_name=child.tag.split("}")[-1]        #spliting to remove namespace, if any
            if(tag_name.lower()=='include'):         #case insensitive search for keyword include
                for key, val in child.attrib.items():
                    if val.endswith('.nml') and val not in filelist_local:           #looking for filenames ending with .nml
                            filelist_local=self.getFileList(val,filelist_local)
        return filelist_local
    
    #function to parse NeuroML files
    def parseNML(self):
        
        #get all the filenames
        self.filelist=self.getFileList(self.fname_LEMS,[])
        
        #get tree for each of the .nml files
        tree=[]
        for file in self.filelist:
            filename=os.path.join(self.path2source, file)
            tree.append(ET.parse(filename))
            
        #registering namespace as blank space (some user tag can also be used)
        ET.register_namespace("","http://www.neuroml.org/schema/neuroml2")
        #ns = {"xmlns":"http://www.neuroml.org/schema/neuroml2"}
        
        return tree
    
    #function to cerate accordion widgets for given root of the xml/nml file
    def createAccordions(self,root):
        
        subwidget_list=[]  #list of subwidgets inside the accordion
        tags=[]            #tags from xml file to be used as accordion tittle
        
        #iterate through each child element to create subwidgets
        for child in root:
            
            tag_name=child.tag.split("}")[-1]        #spliting to remove namespace, if any
            tags.append(tag_name)
            textBox_list = []
            
            #iterate through each attribute of the child element
            for key, val in child.attrib.items():
                    textBox_key   = ipywidgets.Text(value=key,disabled=True,layout=ipywidgets.Layout(width='10%'))
                    textBox_value = ipywidgets.Text(value=val,layout=ipywidgets.Layout(width='40%'))
                    textBox_list.append(ipywidgets.HBox([textBox_key, textBox_value]))
            
            #for notes tag display a textarea and show text as attributes will be empty
            if tag_name=='notes':
                textBox_list.append(ipywidgets.Textarea(value=child.text,layout=ipywidgets.Layout(width='50%')))
            
            #check if grand child exist
            if child:
                #if grand child exist then recursive call to self with root <---> child
                child_accord=self.createAccordions(child)
                textBox_list.append(child_accord)  #append the chlild accordion to parent

            subwidget_list.append(ipywidgets.VBox(textBox_list)) #append sub widgets to the current accordion

        #create accordion widget for the captured subwidgets
        accordion = ipywidgets.Accordion(children=subwidget_list, selected_index=None)
        #set title using tags (xml namespace ignored)
        for i in range(len(tags)):
            accordion.set_title(i, tags[i])
            
        return accordion
        
    def generateDashboard(self,trees):
       
        tab_list=[]          #creating empty tab list
        for tree in trees:
            root = tree.getroot()
            tab_list.append(self.createAccordions(root))        #add accordions to the tab list
        
        #create a nested tab with accordions
        
        tab_nest = ipywidgets.Tab()
        #create tab headers from filenames
        for i in range(len(tab_list)):
            tab_nest.set_title (i, self.filelist[i])
        
        #set content to tabs
        tab_nest.children = tab_list
        display(tab_nest)
        
    #function to update existing NeuroML file based on widget inputs
    def writeNMLinputFile(self,C_m, g_Na, g_K, g_L, E_Na, E_K, E_L, t_0, t_n, delta_t, I_inj_max, I_inj_width, I_inj_trans):
        print('will do later')
        
    #function to plot data generated by NeuroML
    def plotData(self,fname_NML_output):

        #read data file and import columns as array using numpy
        data = np.loadtxt(fname_NML_output)
        t=data[:,0]*1000    #convert to ms
        V=data[:,1]*1000    #convert to mV
        m=data[:,2]
        h=data[:,3]
        n=data[:,4]
        ina=data[:,5]
        ik=data[:,6]
        il=data[:,7]
        i_inj1=data[:,8]*10**9 #convert to nA
        i_inj2=data[:,9]*10**9 #convert to nA

        plt.rcParams['figure.figsize'] = [12, 8]
        plt.rcParams['font.size'] = 15
        plt.rcParams['legend.fontsize'] = 12
        plt.rcParams['legend.loc'] = "upper right"

        fig=plt.figure()

        ax1 = plt.subplot(4,1,1)
        plt.xlim([np.min(t),np.max(t)])  #for all subplots
        plt.title('Hodgkin-Huxley Neuron')
        #i_inj_values = [self.I_inj(t) for t in t]
        plt.plot(t, i_inj1, 'k')
        plt.plot(t, i_inj2, 'b')
        plt.ylabel('$I_{inj}$ (nA)')      

        plt.subplot(4,1,2, sharex = ax1)
        plt.plot(t, ina, 'c', label='$I_{Na}$')
        plt.plot(t, ik, 'y', label='$I_{K}$')
        plt.plot(t, il, 'm', label='$I_{L}$')
        plt.ylabel('Current')
        plt.legend()

        plt.subplot(4,1,3, sharex = ax1)
        plt.plot(t, m, 'r', label='m')
        plt.plot(t, h, 'g', label='h')
        plt.plot(t, n, 'b', label='n')
        plt.ylabel('Gating Value')
        plt.legend()

        plt.subplot(4,1,4, sharex = ax1)
        plt.plot(t, V, 'k')
        plt.ylabel('V (mV)')
        plt.xlabel('t (ms)')
        #plt.ylim(-1, 40)

        plt.tight_layout()
        plt.show()
#end of class